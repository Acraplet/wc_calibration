// This code reads the "data" generated by WCSIM_TreeConvert, which stores the photon hits per PMT,
// then reads the "reference map" (again generated by WCSIM_TreeConvert), and makes predictions based on the fit parameters.
#include "truth_alpha.hh"
#include <iostream>
#include "chisq.h"
#include "Math/Minimizer.h"
#include "Math/Functor.h"
#include "Math/Factory.h"
#include "TFile.h"
#include "TRandom3.h"
#include "TGraph.h"
#include "TH1.h"
#include "TGraphErrors.h"
#include "TSystemDirectory.h"
#include <cstring>

#include "ColorOutput.hh"

const std::string TAG = color::GREEN_STR + "[TestFitter]: " + color::RESET_STR;
const std::string ERR = color::RED_STR + "[ERROR]: " + color::RESET_STR;
const std::string WAR = color::RED_STR + "[WARNING]: " + color::RESET_STR;

using namespace std;

int main(int argc, char **argv){

    std::vector<double> list_R;
    std::vector<double> list_A;
    std::vector<double> list_Q;
    std::vector<double> list_i;

    char * filename=NULL;
    char * reffilename=NULL;
    char * splinefilename=NULL;

    char c;
    while( (c = getopt(argc,argv,"f:r:s:h")) != -1 ){//input in c the argument (-f etc...) and in optarg the next argument. When the above test becomes -1, it means it fails to find a new argument.
        switch(c){
        case 'f': // data
            filename = optarg;
            break;
        case 'r': // reference map
            reffilename = optarg;
            break;
        case 's': // spline file for cathode parameters
            splinefilename = optarg;
            break;
        case 'h':
            std::cout << TAG    << "USAGE: "
                                << "TestFitter" << "\nOPTIONS:\n"
                                << "-f : Data file\n"
                                << "-r : Reference map file\n"
                                << "-s : Spline file for cathode parameters\n"
                                ;
            return 0;
        default:
            return 0;
        }
    }

    // Open the data file
    if (filename==NULL){
        std::cout << ERR << "Error, no input file: " << std::endl;
        return -1;
    }

    TFile* f = new TFile(filename);
    if (!f->IsOpen()){
        std::cout << ERR << "Error, could not open input file: " << filename << std::endl;
        return -1;
    }

    TTree* pmt_type0 = (TTree*)f->Get("pmt_type0");
    TTree* hitRate_pmtType0 = (TTree*)f->Get("hitRate_pmtType0");
    // distance to source
    double R;
    pmt_type0->SetBranchAddress("R",&R);
    int nPMTs = pmt_type0->GetEntries();
    // hit rate histogram
    hitRate_pmtType0->Draw(Form("PMT_id>>(%i,0,%i)",nPMTs,nPMTs),"nPE");
    TH1D* hData = (TH1D*)hitRate_pmtType0->GetHistogram();
    // Fill data entries for fitter
    for (int i = 0 ; i<nPMTs; i++)
    {
        pmt_type0->GetEntry(i);
        list_i.push_back(i);
        list_R.push_back(R);
        list_Q.push_back(hData->GetBinContent(i+1));
    }

    // Open the ref file
    if (reffilename==NULL){
        std::cout << ERR << "Error, no ref file: " << std::endl;
        return -1;
    }

    TFile* fr = new TFile(reffilename);
    if (!fr->IsOpen()){
        std::cout << ERR << "Error, could not open ref file: " << reffilename << std::endl;
        return -1;
    }
    TTree* hitRate_pmtType0r = (TTree*)fr->Get("hitRate_pmtType0");
    hitRate_pmtType0r->Draw(Form("PMT_id>>(%i,0,%i)",nPMTs,nPMTs),"nPE");
    TH1D* hRef = (TH1D*)hitRate_pmtType0r->GetHistogram();
    // Fill reference map
    for (int i = 0 ; i<nPMTs; i++)
    {
        list_A.push_back(hRef->GetBinContent(i+1));
    }

    // for (int i = 0 ; i<nPMTs; i++)
    // {
    //     std::cout<<"i = "<<i<<" "<<list_R[i]<<" "<<list_Q[i]<<" "<<list_A[i]<<"\n";
    // }

    //Here the fitting begins
    const int nPars = 4; // number of fit parameters 
    Chisq *chi = new Chisq(nPars);
    chi->setData(list_i, list_Q);
    chi->setRef(list_A, list_R);
    // Add fit parameters
    chi->AddParameters(kCathode);
    chi->AddParameters(kNorm);
    chi->LoadCathodeSpline(splinefilename);
    ROOT::Math::Functor functor(chi, &Chisq::CalcChiSq, nPars);
    ROOT::Math::Minimizer *min = ROOT::Math::Factory::CreateMinimizer("Minuit2", "Migrad");
    min->SetStrategy(3);
    min->SetFunction(functor);
    min->SetMaxFunctionCalls(10000);
    // Set parameter priors
    min->SetVariable(0, "nRe", 3.1, 0.01);
    min->SetVariableLimits(0, 3.0, 3.4);
    min->SetVariable(1, "nIm", 1.3, 0.01);
    min->SetVariableLimits(1, 1.1, 1.7);
    min->SetVariable(2, "d", 20, 0.01);
    min->SetVariableLimits(2, 11.5, 23.4);
    // min->FixVariable(0);
    // min->FixVariable(1);
    // min->FixVariable(2);
    min->SetVariable(3, "Norm", 1.0, 0.01);
    min->SetVariableLimits(3, 0, 1000);

    std::cout << TAG << "Number of defined parameters: " << min->NDim() << std::endl
              << TAG << "Number of free parameters   : " << min->NFree() << std::endl
              << TAG << "Number of fixed parameters  : " << min->NDim() - min->NFree()
              << std::endl;

    min->Minimize();
    min->PrintResults();
    const double* par_val = min->X();
    const double* par_err = min->Errors();
    for (int i=0;i<nPars;i++)
    {
        std::cout<<"Variable "<<i<<" : "<<par_val[i]<<" +/- "<<par_err[i]<<"\n";
    }
}

